
// Improved app_integration.js
// - fetches audio_manifest.json via fetch (works on file:// only with server; recommended to use http-server)
// - creates a single AudioContext on first user gesture
// - routes <audio> elements through AudioContext GainNode for fade-in/fade-out control
// - ensures initMelodyGenerator() is called if available

let manifest = null;
let audioCache = new Map();
let mediaNodes = new Map(); // filename -> {audio, source, gain}
let alarmTimer = null;
let audioContext = null;
let userInteracted = false;

async function loadManifest(){
  try {
    const res = await fetch('./audio_manifest.json');
    manifest = await res.json();
  } catch(e){
    console.error('Не удалось загрузить manifest:', e);
    manifest = { audio: [] };
  }
}

function ensureAudioContext(){
  if (audioContext) return audioContext;
  try {
    const AC = window.AudioContext || window.webkitAudioContext;
    audioContext = new AC();
  } catch(e){
    console.warn('AudioContext не доступен:', e);
    audioContext = null;
  }
  return audioContext;
}

function onFirstUserGesture(){
  if (userInteracted) return;
  userInteracted = true;
  ensureAudioContext();
  // resume if suspended
  if (audioContext && audioContext.state === 'suspended') {
    audioContext.resume().catch(()=>{});
  }
}

function createMediaNode(filename){
  // create <audio> and connect to AudioContext gain for fade control
  const audio = new Audio('./audio/' + encodeURIComponent(filename));
  audio.preload = 'auto';
  audio.crossOrigin = 'anonymous';
  const info = { audio, source: null, gain: null };
  const ac = ensureAudioContext();
  if (ac){
    try {
      const source = ac.createMediaElementSource(audio);
      const gain = ac.createGain();
      gain.gain.value = 1.0;
      source.connect(gain);
      gain.connect(ac.destination);
      info.source = source;
      info.gain = gain;
    } catch(e){
      console.warn('Не удалось создать MediaElementSource:', e);
    }
  }
  mediaNodes.set(filename, info);
  return info;
}

async function playAudioWithFade(filename, targetVol=0.8, fadeInSec=1.2){
  onFirstUserGesture();
  let info = mediaNodes.get(filename);
  if (!info) info = createMediaNode(filename);
  const audio = info.audio;
  // ensure loaded
  await new Promise(resolve => {
    if (audio.readyState >= 3) return resolve();
    const t = setTimeout(()=> resolve(), 2500);
    audio.addEventListener('canplay', ()=>{ clearTimeout(t); resolve(); }, {once:true});
    audio.addEventListener('error', ()=>{ clearTimeout(t); resolve(); }, {once:true});
  });
  // stop/reset
  try { audio.pause(); audio.currentTime = 0; } catch(e){}
  if (info.gain && audioContext){
    const now = audioContext.currentTime;
    info.gain.gain.cancelScheduledValues(now);
    info.gain.gain.setValueAtTime(0.0001, now); // start very low to avoid clicks
    info.gain.gain.exponentialRampToValueAtTime(Math.max(0.0001, targetVol), now + Math.max(0.01, fadeInSec));
  } else {
    try { audio.volume = targetVol; } catch(e){}
  }
  const p = audio.play();
  if (p && p.catch) p.catch(()=>{});
  return audio;
}

function stopAllAudio(fadeOutSec=0.6){
  for (const [name, info] of mediaNodes.entries()){
    try {
      if (info.gain && audioContext){
        const now = audioContext.currentTime;
        info.gain.gain.cancelScheduledValues(now);
        info.gain.gain.setValueAtTime(info.gain.gain.value || 1, now);
        info.gain.gain.exponentialRampToValueAtTime(0.0001, now + Math.max(0.01, fadeOutSec));
        // schedule pause after fade
        setTimeout(()=>{ try{ info.audio.pause(); info.audio.currentTime = 0;}catch(e){} }, Math.ceil((fadeOutSec+0.1)*1000));
      } else {
        info.audio.pause();
        info.audio.currentTime = 0;
      }
    } catch(e){ console.warn(e); }
  }
  if (typeof natureSoundsGenerator !== 'undefined' && natureSoundsGenerator && natureSoundsGenerator.stop) {
    try{ natureSoundsGenerator.stop(); }catch(e){}
  }
  if (alarmTimer){ clearTimeout(alarmTimer); alarmTimer = null; }
}

function renderList(){
  const container = document.getElementById('audioList');
  container.innerHTML = '';
  const list = manifest && manifest.audio ? manifest.audio : [];
  for (let i=0;i<list.length && i<200;i++){
    const name = list[i];
    const card = document.createElement('div');
    card.className = 'card';
    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.innerHTML = `<div>${name}</div><div class="small">Нажмите ▶ чтобы проиграть</div>`;
    const btn = document.createElement('button');
    btn.textContent = '▶';
    btn.addEventListener('click', async ()=>{
      btn.textContent = '...';
      try {
        await playAudioWithFade(name, Number(document.getElementById('volume').value || 0.8), 0.8);
        btn.textContent = '❚❚';
      } catch(e){
        console.error(e);
        btn.textContent = '⚠';
        setTimeout(()=> btn.textContent = '▶', 800);
      }
    });
    card.appendChild(meta);
    card.appendChild(btn);
    container.appendChild(card);
  }
}

function setWakeUp(timeStr){
  if (alarmTimer){ clearTimeout(alarmTimer); alarmTimer = null; }
  const now = new Date();
  const [hh, mm] = timeStr.split(':').map(Number);
  const target = new Date(now);
  target.setHours(hh, mm, 0, 0);
  if (target <= now) target.setDate(target.getDate() + 1);
  const ms = target - now;
  console.log('Alarm set for', target.toString(), 'in', ms, 'ms');
  alarmTimer = setTimeout(async ()=>{
    try {
      const vol = Number(document.getElementById('volume').value) || 0.8;
      // 1) soft track
      const soft = (manifest && manifest.audio && manifest.audio.length) ? manifest.audio[0] : null;
      if (soft) await playAudioWithFade(soft, Math.min(0.35, vol*0.45), 2.5);
      // 2) after 18s start nature generator (if available)
      setTimeout(()=>{
        try {
          if (typeof natureSoundsGenerator !== 'undefined' && natureSoundsGenerator && natureSoundsGenerator.generateAndPlay){
            natureSoundsGenerator.generateAndPlay({environment: 'morning', duration: 120, fadeInTime: 12});
          }
        } catch(e){ console.error(e); }
      }, 18000);
      // 3) after 35s play motivational clip
      setTimeout(async ()=>{
        const idx = Math.floor(Math.random()*(manifest && manifest.audio ? manifest.audio.length : 1));
        const file = manifest.audio[idx];
        await playAudioWithFade(file, Math.min(1, vol), 1.2);
      }, 35000);
    } catch(e){ console.error(e); }
    alarmTimer = null;
  }, ms);
  alert('Будильник установлен на '+ target.toLocaleString());
}

// Attach event listeners and initialization
document.addEventListener('DOMContentLoaded', async ()=>{
  // listen for first user interaction to unlock audio
  ['click','keydown','touchstart'].forEach(evt => document.addEventListener(evt, onFirstUserGesture, {once:true}));

  await loadManifest();
  renderList();

  // try to init generator if available
  try {
    if (typeof initMelodyGenerator === 'function') {
      initMelodyGenerator();
    }
  } catch(e){ console.warn('initMelodyGenerator error', e); }

  document.getElementById('setWake').addEventListener('click', ()=>{
    const t = document.getElementById('wakeTime').value;
    if (!t){ alert('Укажите время'); return; }
    setWakeUp(t);
  });
  document.getElementById('stopAll').addEventListener('click', ()=>{
    stopAllAudio();
  });
  document.getElementById('genPlay').addEventListener('click', ()=>{
    const env = document.getElementById('envSelect').value || 'forest';
    if (typeof natureSoundsGenerator !== 'undefined' && natureSoundsGenerator && natureSoundsGenerator.generateAndPlay) {
      natureSoundsGenerator.generateAndPlay({environment: env, duration: 90, fadeInTime: 8});
    } else {
      alert('Генератор недоступен в этом окружении');
    }
  });
  document.getElementById('genStop').addEventListener('click', ()=>{
    if (typeof natureSoundsGenerator !== 'undefined' && natureSoundsGenerator && natureSoundsGenerator.stop) {
      natureSoundsGenerator.stop();
    }
  });
});
